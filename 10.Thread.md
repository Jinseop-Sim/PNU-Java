# Thread
---
## What is Thread?
>> *"Thread is a execution unit!"*    

> 카카오톡을 예로 들어보자, Message Display 부분과 입력 부와 통신 부가 각각 나누어져있다.  
> 이것들을 __Execution Unit__ 으로 따로따로 구현해 동시에 병렬로 동작하도록 한다.   
> 이 때 실행되는 Execution Unit의 Task, 하나의 Task를 Thread라고 한다.  

## Thread의 특징
- Java는 OOL(Object Oriented Language)이므로, Thread 또한 Object로 구현한다.
- main() 외의 Thread를 사용하려면, __Thread Class__ 를 상속하거나 __Runnable Interface__ 를 구현해야한다.
- 각 Thread는 메모리 공간을 공유한다. ( __멤버 변수의 공유__ )
- Thread의 Scheduling은 JVM에서 알아서 Random하게 담당한다.
  - 따라서 Thread Syncronization이 매우 중요하다!

## Thread Class
```java
public class ThreadTest {
	public static void main(String[] args) {
		Runnable printA = new PrintChar('a', 100); // Runnable Interface의 Instance
		Runnable printB = new PrintChar('b', 100);
		Runnable print100 = new PrintNum(100);
		
		Thread thread1 = new Thread(printA); // Thread의 인자는 객체가 되어야 한다.
		Thread thread2 = new Thread(printB);
		Thread thread3 = new Thread(print100);
		
		thread1.start(); // Thread의 실행 method.
		thread2.start();
    thread3.start();
	}
}

class PrintChar implements Runnable{
	private char charToprint;
	private int times; // times to repeats 
	
	public PrintChar(char c, int t) {
		charToprint = c;
		times = t;
	}
	@Override
	public void run() {
		for(int i = 0; i < times; i++) {
			System.out.print(charToprint);
		}
	}
}
class PrintNum implements Runnable{
	private int lastNum;
	
	public PrintNum(int n) {
		lastNum = n;
	}
	@Override
	public void run() {
		for(int i = 1; i<=lastNum; i++) {
			System.out.print(" " + i);
		}
	}
}
```
- 위의 예제는 4개의 Thread를 갖고있다.
  - Main, printA, printB, print100이 각각 4개의 Thread가 된다.
- 실행을 해보면 알겠지만, 위 Thread들의 실행 순서는 JVM의 Scheduling에 의해 Random하게 된다.
- Thread는 Runnable Interface를 상속받은 Instance를 Method의 Argument로 받는다.

### Thread Yield
```java
class PrintNum implements Runnable{
	private int lastNum;
	
	public PrintNum(int n) {
		lastNum = n;
	}
	@Override
	public void run() {
		for(int i = 1; i<=lastNum; i++) {
      Thread.yield(); // yield는 실행 순서를 양보한다는 의미이다.
			System.out.print(" " + i);
		}
	}
}
```
- ```Thread.yield()``` method를 만나는 순간, Scheduling 되어있는 다른 Thread에게 실행 순서를 양보한다.
### Thread Join
> 특이한 Method로, 어떤 Thread가 실행된 후에 다른 Thread를 Join 시켜   
> 그 Thread가 끝날 때 까지 기다렸다가 다시 원래 Thread로 돌아온다.  
```java
public class ThreadJoin {
	public static void main(String[] args) {
		System.out.println(Thread.currentThread().getName() + "start");
		Runnable r = new MyRunnable();
		Thread thread = new Thread(r);
		thread.start();
		System.out.println(Thread.currentThread().getName() + "end");
	}
}
class MyRunnable implements Runnable{
	@Override
	public void run() {
		// TODO Auto-generated method stub
		System.out.println("Thread 1");
		thread2();
	}
	public void thread2() {
		System.out.println("Thread 2");
		thread3();
	}
	public void thread3() {
		System.out.println("Thread 3");
	}
}
```
- 위와 같이 Thread를 실행하게 되면, Multi Thread는 Main() Thread가 종료되어도 백그라운드에 계속 실행된다.
	- 즉, START END까지 출력된 뒤에 Thread 1 2 3 이 출력되는 것이다.
- 그럼 아래와 같이 코드를 바꿔보자.
```java
public class ThreadJoin {
	public static void main(String[] args) {
		System.out.println(Thread.currentThread().getName() + " START ! ");
		Runnable r = new MyRunnable();
		Thread thread = new Thread(r);
		thread.start();
		try {
			thread.join();
		}catch (InterruptedException ex) {
			ex.printStackTrace();
		}
		System.out.println(Thread.currentThread().getName() + " END .. ");
	}
}
```
- 메인 함수를 이렇게 Join을 이용해서 바꾸어주면, Thread의 Scheduling이 바뀌게 된다.
- Main Thread가 실행된 뒤, MyRunnable Thread를 Join 시켜서 해당 Thread들이 끝날 때 까지 기다렸다가 Main을 마저 실행시키는 방식이다.

### Set Priority of Thread
```java
thread3.setPriority(Thread.MAX_PRIORITY); // 이렇게 해당 thread의 우선순위를 높일 수 있다.
thread1.start();
thread2.start();
thread3.start();
```
- 물론 이 방법으로 해당 Thread의 우선순위를 높일 수 있는 것은 맞다.
  - 하지만 이 method를 너무 맹신해서는 안된다.
  - 왜냐하면 나머지 Thread들이 이미 MAX_PRIORITY라서 동등한 우선순위를 갖게 될 수도 있고, 어떻게 될지 모르는 일이다.
  - 모두 동등한 Priority를 가진다면, Round Robin으로 Thread를 실행할 것이다.
