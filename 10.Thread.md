# Thread
---
## What is Thread?
>> *"Thread is a execution unit!"*    

> 카카오톡을 예로 들어보자, Message Display 부분과 입력 부와 통신 부가 각각 나누어져있다.  
> 이것들을 __Execution Unit__ 으로 따로따로 구현해 동시에 병렬로 동작하도록 한다.   
> 이 때 Task가 실행되는 흐름을 모두 __Thread__ 라고 칭한다.  

## Thread의 특징
- Java는 OOL(Object Oriented Language)이므로, Thread 또한 Object로 구현한다.
- 각 Thread는 메모리 공간을 공유한다. ( __멤버 변수의 공유__ )
- Thread의 Scheduling은 JVM에서 알아서 Random하게 담당한다.
  - 따라서 Thread Syncronization이 매우 중요하다!

## Thread Class
```java
public class ThreadTest {
	public static void main(String[] args) {
		Runnable printA = new PrintChar('a', 100); // Runnable Interface의 Instance
		Runnable printB = new PrintChar('b', 100);
		Runnable print100 = new PrintNum(100);
		
		Thread thread1 = new Thread(printA); // Thread의 인자는 객체가 되어야 한다.
		Thread thread2 = new Thread(printB);
		Thread thread3 = new Thread(print100);
		
		thread1.start(); // Thread의 실행 method.
		thread2.start();
    thread3.start();
	}
}

class PrintChar implements Runnable{
	private char charToprint;
	private int times; // times to repeats 
	
	public PrintChar(char c, int t) {
		charToprint = c;
		times = t;
	}
	@Override
	public void run() {
		for(int i = 0; i < times; i++) {
			System.out.print(charToprint);
		}
	}
}
class PrintNum implements Runnable{
	private int lastNum;
	
	public PrintNum(int n) {
		lastNum = n;
	}
	@Override
	public void run() {
		for(int i = 1; i<=lastNum; i++) {
			System.out.print(" " + i);
		}
	}
}
```
- 위의 예제는 4개의 Thread를 갖고있다.
  - Main, printA, printB, print100이 각각 4개의 Thread가 된다.
- 실행을 해보면 알겠지만, 위 Thread들의 실행 순서는 JVM의 Scheduling에 의해 Random하게 된다.
- Thread는 Runnable Interface를 상속받은 Instance를 Method의 Argument로 받는다.

### Thread Yield
```java
class PrintNum implements Runnable{
	private int lastNum;
	
	public PrintNum(int n) {
		lastNum = n;
	}
	@Override
	public void run() {
		for(int i = 1; i<=lastNum; i++) {
      Thread.yield(); // yield는 실행 순서를 양보한다는 의미이다.
			System.out.print(" " + i);
		}
	}
}
```
- ```Thread.yield()``` method를 만나는 순간, Scheduling 되어있는 다른 Thread에게 실행 순서를 양보한다.
### Thread Join
### Set Priority of Thread
```java
thread3.setPriority(Thread.MAX_PRIORITY); // 이렇게 해당 thread의 우선순위를 높일 수 있다.
thread1.start();
thread2.start();
thread3.start();
```
- 물론 이 방법으로 해당 Thread의 우선순위를 높일 수 있는 것은 맞다.
  - 하지만 이 method를 너무 맹신해서는 안된다.
  - 왜냐하면 나머지 Thread들이 이미 MAX_PRIORITY라서 동등한 우선순위를 갖게 될 수도 있고, 어떻게 될지 모르는 일이다.
  - 모두 동등한 Priority를 가진다면, Round Robin으로 Thread를 실행할 것이다.
